@inherits BladixComponentBase

@if (AsChild)
{
    <CascadingValue Value="this" IsFixed="true">
        @ChildContent
    </CascadingValue>
}
else
{
    <div @attributes="AdditionalAttributes"
         data-orientation="@Orientation.ToString().ToLowerInvariant()"
         data-bladix-accordion="true"
         class="@Class"
         style="@Style"
         @ref="ElementRef">
        <CascadingValue Value="this" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
}

@code {
    private readonly List<string> _openItems = new();
    private readonly List<AccordionTrigger> _triggers = new();
    private AccordionTrigger? _tabbableTrigger;

    [Parameter] public AccordionType Type { get; set; } = AccordionType.Single;
    [Parameter] public bool Collapsible { get; set; } = false;

    [Parameter] public object? Value { get; set; }
    [Parameter] public EventCallback<object?> OnValueChange { get; set; }

    [Parameter] public object? DefaultValue { get; set; }

    [Parameter] public Orientation Orientation { get; set; } = Orientation.Vertical;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public Direction Dir { get; set; } = Direction.Ltr;

    protected override void OnInitialized()
    {
        if (Type == AccordionType.Single)
        {
            var vals = ToStringEnumerable(Value ?? DefaultValue).ToArray();
            if (vals.Length > 0)
            {
                _openItems.Clear();
                _openItems.Add(vals[0]);
            }
        }
        else
        {
            var initial = ToStringEnumerable(DefaultValue);
            SetOpenItemsFromEnumerable(initial);
        }
    }

    protected override void OnParametersSet()
    {
        if (Type == AccordionType.Single)
        {
            var vals = ToStringEnumerable(Value).ToArray();
            if (vals.Length >= 1)
            {
                var v = vals[0];
                if (_openItems.Count != 1 || !_openItems.Contains(v, StringComparer.Ordinal))
                {
                    _openItems.Clear();
                    _openItems.Add(v);
                }
            }
            else if (Value == null)
            {
                if (Collapsible)
                {
                    _openItems.Clear();
                }
            }
        }
        else
        {
            // Multiple mode
            if (Value != null)
            {
                var vals = ToStringEnumerable(Value);
                SetOpenItemsFromEnumerable(vals);
            }
            // If Value is null -> uncontrolled: keep internal state
        }
    }

    public bool IsItemOpen(string itemValue) => _openItems.Contains(itemValue, StringComparer.Ordinal);

    public async Task ToggleItem(string itemValue)
    {
        if (Disabled) return;

        // Controlled vs uncontrolled:
        // - If Value != null -> controlled: compute new payload and only emit OnValueChange (do not mutate internal state)
        // - If Value == null -> uncontrolled: update internal state and emit OnValueChange for consumers if they listen
        bool isControlled = Value != null;

        if (Type == AccordionType.Single)
        {
            if (isControlled)
            {
                // derive current value from Value
                var current = ToStringEnumerable(Value).FirstOrDefault();
                if (string.Equals(current, itemValue, StringComparison.Ordinal))
                {
                    // item is open -> attempt to close if collapsible
                    if (Collapsible)
                        await OnValueChange.InvokeAsync(null);
                }
                else
                {
                    // open requested
                    await OnValueChange.InvokeAsync(itemValue);
                }

                return;
            }

            // Uncontrolled: mutate internal state
            if (_openItems.Contains(itemValue, StringComparer.Ordinal))
            {
                if (Collapsible)
                {
                    _openItems.Clear();
                    await OnValueChange.InvokeAsync(null);
                }
            }
            else
            {
                _openItems.Clear();
                _openItems.Add(itemValue);
                var payload = ConvertOpenItemsToValue();
                await OnValueChange.InvokeAsync(payload);
            }
        }
        else
        {
            // Multiple
            if (isControlled)
            {
                var current = ToStringEnumerable(Value).ToList();
                if (current.Contains(itemValue, StringComparer.Ordinal))
                    current.RemoveAll(s => string.Equals(s, itemValue, StringComparison.Ordinal));
                else
                    current.Add(itemValue);

                await OnValueChange.InvokeAsync(current.ToArray());
                return;
            }

            // Uncontrolled: mutate internal state
            if (_openItems.Contains(itemValue, StringComparer.Ordinal))
                _openItems.RemoveAll(s => string.Equals(s, itemValue, StringComparison.Ordinal));
            else
                _openItems.Add(itemValue);

            var payload = ConvertOpenItemsToValue();
            await OnValueChange.InvokeAsync(payload);
        }

        StateHasChanged();
    }

    public void RegisterTrigger(AccordionTrigger trigger)
    {
        if (!_triggers.Contains(trigger))
            _triggers.Add(trigger);

        // initialize the tabbable trigger to the first non-disabled trigger
        if (_tabbableTrigger == null && !trigger.IsDisabled)
        {
            _tabbableTrigger = trigger;
            StateHasChanged();
        }
    }

    public void UnregisterTrigger(AccordionTrigger trigger)
    {
        _triggers.Remove(trigger);
        if (_tabbableTrigger == trigger)
        {
            _tabbableTrigger = GetFirstTrigger();
            StateHasChanged();
        }
    }

    public AccordionTrigger? GetNextTrigger(AccordionTrigger current)
    {
        int currentIndex = _triggers.IndexOf(current);
        if (currentIndex == -1) return null;
        for (int i = currentIndex + 1; i < _triggers.Count; i++)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        for (int i = 0; i < currentIndex; i++)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        return null;
    }

    public AccordionTrigger? GetPreviousTrigger(AccordionTrigger current)
    {
        int currentIndex = _triggers.IndexOf(current);
        if (currentIndex == -1) return null;
        for (int i = currentIndex - 1; i >= 0; i--)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        for (int i = _triggers.Count - 1; i > currentIndex; i--)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        return null;
    }

    public AccordionTrigger? GetFirstTrigger() => _triggers.FirstOrDefault(t => !t.IsDisabled);
    public AccordionTrigger? GetLastTrigger() => _triggers.LastOrDefault(t => !t.IsDisabled);

    // Roving tabindex helpers
    public void SetTabbableTrigger(AccordionTrigger? trigger)
    {
        if (trigger != null && trigger.IsDisabled) return;
        if (_tabbableTrigger == trigger) return;
        _tabbableTrigger = trigger;
        StateHasChanged();
    }

    public int GetTabIndex(AccordionTrigger trigger)
    {
        // default to 0 when no root (e.g., AsChild) so element remains tabbable
        if (_tabbableTrigger == null) return 0;
        return _tabbableTrigger == trigger ? 0 : -1;
    }

    private object? ConvertOpenItemsToValue()
    {
        if (Type == AccordionType.Single)
        {
            return _openItems.FirstOrDefault();
        }

        // Multiple: preserve insertion order and unique values
        return _openItems.ToArray();
    }

    private void SetOpenItemsFromEnumerable(IEnumerable<string> values)
    {
        _openItems.Clear();
        foreach (var v in values)
        {
            if (string.IsNullOrEmpty(v)) continue;
            if (!_openItems.Contains(v, StringComparer.Ordinal))
                _openItems.Add(v);
        }
    }

    private static IEnumerable<string> ToStringEnumerable(object? value)
    {
        if (value == null) yield break;

        switch (value)
        {
            case string s:
                // treat a single string as a single value (do NOT split by comma)
                if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case string[] sa:
                foreach (var s in sa) if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case IEnumerable<string> seq:
                foreach (var s in seq) if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case System.Collections.IEnumerable nonGeneric:
                foreach (var item in nonGeneric)
                {
                    var str = item?.ToString();
                    if (!string.IsNullOrEmpty(str)) yield return str!;
                }
                yield break;

            default:
                var strDefault = value.ToString();
                if (!string.IsNullOrEmpty(strDefault)) yield return strDefault;
                yield break;
        }
    }
}
