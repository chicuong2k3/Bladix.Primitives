@inherits BladixComponentBase

@if (AsChild)
{
    <CascadingValue Value="this" IsFixed="true">
        @if (ChildContentWithAttributes != null)
        {
            @ChildContentWithAttributes(BuildSplatAttributes())
        }
        else
        {
            @ChildContent
        }
    </CascadingValue>
}
else
{
    <div @attributes="AdditionalAttributes"
         data-orientation="@Orientation.ToString().ToLowerInvariant()"
         data-bladix-accordion="true"
         class="@Class"
         style="@Style"
         @ref="ElementRef">
        <CascadingValue Value="this" IsFixed="true">
            @ChildContent
        </CascadingValue>
    </div>
}

@code {
    private readonly List<string> _openItems = new();
    private readonly List<AccordionTrigger> _triggers = new();
    private AccordionTrigger? _tabbableTrigger;

    [Parameter] public AccordionType Type { get; set; } = AccordionType.Single;
    [Parameter] public bool Collapsible { get; set; } = false;

    [Parameter] public object? Value { get; set; }
    [Parameter] public EventCallback<object?> OnValueChange { get; set; }

    [Parameter] public object? DefaultValue { get; set; }

    [Parameter] public Orientation Orientation { get; set; } = Orientation.Vertical;
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public Direction Dir { get; set; } = Direction.Ltr;

    protected override void OnInitialized()
    {
        if (Type == AccordionType.Single)
        {
            var vals = ToStringEnumerable(Value ?? DefaultValue).ToArray();
            if (vals.Length > 0)
            {
                _openItems.Clear();
                _openItems.Add(vals[0]);
            }
        }
        else
        {
            var initial = ToStringEnumerable(DefaultValue);
            SetOpenItemsFromEnumerable(initial);
        }
    }

    protected override void OnParametersSet()
    {
        if (Type == AccordionType.Single)
        {
            var vals = ToStringEnumerable(Value).ToArray();
            if (vals.Length >= 1)
            {
                var v = vals[0];
                if (_openItems.Count != 1 || !_openItems.Contains(v, StringComparer.Ordinal))
                {
                    _openItems.Clear();
                    _openItems.Add(v);
                }
            }
            else if (Value == null)
            {
                if (Collapsible)
                {
                    _openItems.Clear();
                }
            }
        }
        else
        {
            // Multiple mode
            if (Value != null)
            {
                var vals = ToStringEnumerable(Value);
                SetOpenItemsFromEnumerable(vals);
            }
            // If Value is null -> uncontrolled: keep internal state
        }
    }

    public bool IsItemOpen(string itemValue) => _openItems.Contains(itemValue, StringComparer.Ordinal);

    public async Task ToggleItem(string itemValue)
    {
        if (Disabled) return;

        bool isControlled = Value != null;

        if (Type == AccordionType.Single)
        {
            if (isControlled)
            {
                var current = ToStringEnumerable(Value).FirstOrDefault();
                if (string.Equals(current, itemValue, StringComparison.Ordinal))
                {
                    if (Collapsible)
                        await OnValueChange.InvokeAsync(null);
                }
                else
                {
                    await OnValueChange.InvokeAsync(itemValue);
                }

                return;
            }

            if (_openItems.Contains(itemValue, StringComparer.Ordinal))
            {
                if (Collapsible)
                {
                    _openItems.Clear();
                    await OnValueChange.InvokeAsync(null);
                }
            }
            else
            {
                _openItems.Clear();
                _openItems.Add(itemValue);
                var payload = ConvertOpenItemsToValue();
                await OnValueChange.InvokeAsync(payload);
            }
        }
        else
        {
            if (isControlled)
            {
                var current = ToStringEnumerable(Value).ToList();
                if (current.Contains(itemValue, StringComparer.Ordinal))
                    current.RemoveAll(s => string.Equals(s, itemValue, StringComparison.Ordinal));
                else
                    current.Add(itemValue);

                await OnValueChange.InvokeAsync(current.ToArray());
                return;
            }

            if (_openItems.Contains(itemValue, StringComparer.Ordinal))
                _openItems.RemoveAll(s => string.Equals(s, itemValue, StringComparison.Ordinal));
            else
                _openItems.Add(itemValue);

            var payload = ConvertOpenItemsToValue();
            await OnValueChange.InvokeAsync(payload);
        }

        StateHasChanged();
    }

    public void RegisterTrigger(AccordionTrigger trigger)
    {
        if (!_triggers.Contains(trigger))
            _triggers.Add(trigger);

        if (_tabbableTrigger == null && !trigger.IsDisabled)
        {
            _tabbableTrigger = trigger;
            StateHasChanged();
        }
    }

    public void UnregisterTrigger(AccordionTrigger trigger)
    {
        _triggers.Remove(trigger);
        if (_tabbableTrigger == trigger)
        {
            _tabbableTrigger = GetFirstTrigger();
            StateHasChanged();
        }
    }

    public AccordionTrigger? GetNextTrigger(AccordionTrigger current)
    {
        int currentIndex = _triggers.IndexOf(current);
        if (currentIndex == -1) return null;
        for (int i = currentIndex + 1; i < _triggers.Count; i++)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        for (int i = 0; i < currentIndex; i++)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        return null;
    }

    public AccordionTrigger? GetPreviousTrigger(AccordionTrigger current)
    {
        int currentIndex = _triggers.IndexOf(current);
        if (currentIndex == -1) return null;
        for (int i = currentIndex - 1; i >= 0; i--)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        for (int i = _triggers.Count - 1; i > currentIndex; i--)
            if (!_triggers[i].IsDisabled) return _triggers[i];
        return null;
    }

    public AccordionTrigger? GetFirstTrigger() => _triggers.FirstOrDefault(t => !t.IsDisabled);
    public AccordionTrigger? GetLastTrigger() => _triggers.LastOrDefault(t => !t.IsDisabled);

    // Roving tabindex helpers
    public void SetTabbableTrigger(AccordionTrigger? trigger)
    {
        if (trigger != null && trigger.IsDisabled) return;
        if (_tabbableTrigger == trigger) return;
        _tabbableTrigger = trigger;
        StateHasChanged();
    }

    public int GetTabIndex(AccordionTrigger trigger)
    {
        // If no explicit tabbable trigger is set yet, fall back to the first non-disabled trigger.
        // This helps ensure a sensible initial tabindex during first interactive render/hydration.
        if (_tabbableTrigger == null)
        {
            var first = GetFirstTrigger();
            if (first == null) return -1;
            return first == trigger ? 0 : -1;
        }

        return _tabbableTrigger == trigger ? 0 : -1;
    }

    private object? ConvertOpenItemsToValue()
    {
        if (Type == AccordionType.Single)
        {
            return _openItems.FirstOrDefault();
        }

        return _openItems.ToArray();
    }

    private void SetOpenItemsFromEnumerable(IEnumerable<string> values)
    {
        _openItems.Clear();
        foreach (var v in values)
        {
            if (string.IsNullOrEmpty(v)) continue;
            if (!_openItems.Contains(v, StringComparer.Ordinal))
                _openItems.Add(v);
        }
    }

    private static IEnumerable<string> ToStringEnumerable(object? value)
    {
        if (value == null) yield break;

        switch (value)
        {
            case string s:
                if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case string[] sa:
                foreach (var s in sa) if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case IEnumerable<string> seq:
                foreach (var s in seq) if (!string.IsNullOrEmpty(s)) yield return s;
                yield break;

            case System.Collections.IEnumerable nonGeneric:
                foreach (var item in nonGeneric)
                {
                    var str = item?.ToString();
                    if (!string.IsNullOrEmpty(str)) yield return str!;
                }
                yield break;

            default:
                var strDefault = value.ToString();
                if (!string.IsNullOrEmpty(strDefault)) yield return strDefault;
                yield break;
        }
    }

    // --- New: AsChild helpers to match Radix expectations ---

    // Allow a child element to pass back the ElementReference when AsChild is used.
    public void SetElementRef(ElementReference elementRef)
    {
        ElementRef = elementRef;
    }

    // Build attribute dictionary for AsChild so the child receives data-orientation, class/style merged, etc.
    private Dictionary<string, object> BuildSplatAttributes()
    {
        var attrs = new Dictionary<string, object>(AdditionalAttributes ?? new Dictionary<string, object>());

        // Merge class attribute: preserve both component Class and user-provided class
        if (attrs.TryGetValue("class", out var userClassObj) && userClassObj is string userClass && !string.IsNullOrEmpty(userClass))
        {
            attrs["class"] = string.IsNullOrEmpty(Class) ? userClass : $"{Class} {userClass}";
        }
        else if (!string.IsNullOrEmpty(Class))
        {
            attrs["class"] = Class;
        }

        // Merge style
        if (!string.IsNullOrEmpty(Style))
        {
            if (attrs.TryGetValue("style", out var userStyleObj) && userStyleObj is string userStyle && !string.IsNullOrEmpty(userStyle))
                attrs["style"] = $"{userStyle};{Style}";
            else
                attrs["style"] = Style;
        }

        // Core attributes to forward
        attrs["data-orientation"] = Orientation.ToString().ToLowerInvariant();
        attrs["data-bladix-accordion"] = "true";

        // We do not set @ref here (Blazor doesn't support passing @ref via attribute splatting).
        // Child should call CascadingParameter to get this root and call SetElementRef(myRef) in its OnAfterRenderAsync.

        return attrs;
    }
}
