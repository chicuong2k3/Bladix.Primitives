@inject IJSRuntime JSRuntime
@inherits BladixComponentBase
@implements IAsyncDisposable

@if (AsChild)
{
    @ChildContent
}
else
{
    <button type="button"
            id="@Item?.TriggerId"
            @attributes="AdditionalAttributes"
            @onclick="HandleClick"
            @onfocus="HandleFocus"
            @onkeydown="HandleKeyDown"
            aria-expanded="@(Item?.IsOpen == true ? "true" : "false")"
            aria-controls="@(Item?.ContentId)"
            aria-disabled="@(_isDisabled ? "true" : null)"
            tabindex="@(Root?.GetTabIndex(this) ?? 0)"
            data-state="@(Item?.IsOpen == true ? "open" : "closed")"
            data-disabled="@(_isDisabled ? "true" : null)"
            data-orientation="@Root?.Orientation.ToString().ToLowerInvariant()"
            disabled="@(_isDisabled ? true : (bool?)null)"
            class="@Class" style="@Style"
            @ref="ElementRef">
        @ChildContent
    </button>
}

@code {
    private bool _isDisabled;
    private BladixDom? _bladixDom;
    private AccordionKeyboard? _accordionKeyboard;

    // keyboard setup state helpers to allow setup when a trigger becomes enabled after initial render
    private bool _keyboardSetupRequested;
    private bool _keyboardSetupInitialized;

    public bool IsDisabled => _isDisabled;

    [CascadingParameter] public AccordionRoot? Root { get; set; }
    [CascadingParameter] public AccordionItem? Item { get; set; }

    protected override void OnInitialized()
    {
        _bladixDom = new BladixDom(JSRuntime);
        _accordionKeyboard = new AccordionKeyboard(JSRuntime);
        // registration moved to OnAfterRenderAsync to preserve DOM order
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender || _keyboardSetupRequested)
        {
            // register with item and root after render to preserve DOM order for keyboard navigation
            Item?.RegisterTrigger(this);
            Root?.RegisterTrigger(this);

            // ensure keyboard setup if this trigger is enabled
            if (!_isDisabled && Root != null && _accordionKeyboard != null && !_keyboardSetupInitialized)
            {
                try
                {
                    await _accordionKeyboard!.SetupKeyboardNavigation(
                        ElementRef,
                        Root.Orientation
                    );
                    _keyboardSetupInitialized = true;
                    _keyboardSetupRequested = false;
                }
                catch (JSException) { /* Silently handle */ }
                catch (InvalidOperationException) { /* Handle JSRuntime unavailable */ }
            }
        }
    }

    protected override void OnParametersSet()
    {
        var prevDisabled = _isDisabled;
        _isDisabled = (Item?.Disabled == true || Root?.Disabled == true);

        // If this trigger became disabled and was the tabbable trigger, move tabbable to first non-disabled
        if (_isDisabled && Root != null && Root.GetTabIndex(this) == 0)
        {
            Root.SetTabbableTrigger(Root.GetFirstTrigger());
        }

        // If this trigger became enabled (was disabled before) ensure there's a tabbable trigger.
        if (prevDisabled && !_isDisabled && Root != null)
        {
            if (Root.GetTabIndex(this) == -1 || Root.GetFirstTrigger() == this)
            {
                Root.SetTabbableTrigger(this);
            }

            // request keyboard setup for next render (we avoid calling JSRuntime synchronously here)
            _keyboardSetupRequested = true;
            _keyboardSetupInitialized = false;
        }
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        if (!_isDisabled && Item != null)
        {
            // Ensure roving tabindex follows interaction
            Root?.SetTabbableTrigger(this);
            await Item.Toggle();
        }
    }

    private Task HandleFocus(FocusEventArgs e)
    {
        if (_isDisabled || Root == null) return Task.CompletedTask;

        // When a trigger receives focus (mouse or programmatic), make it the tabbable trigger
        Root.SetTabbableTrigger(this);
        return Task.CompletedTask;
    }

    /// <summary>
    /// Handles keyboard navigation for accordion triggers.
    /// Vertical: ArrowUp/ArrowDown/Home/End
    /// Horizontal: ArrowLeft/ArrowRight/Home/End (with RTL support)
    /// preventDefault is handled by AccordionKeyboard via JS module
    /// </summary>
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_isDisabled || Root == null) return;

        bool isVertical = Root.Orientation == Orientation.Vertical;
        bool isRtl = Root.Dir == Direction.Rtl;

        switch (e.Key)
        {
            case "ArrowDown" when isVertical:
            case "ArrowRight" when !isVertical && !isRtl:
            case "ArrowLeft" when !isVertical && isRtl:
                await FocusNextTrigger();
                break;

            case "ArrowUp" when isVertical:
            case "ArrowLeft" when !isVertical && !isRtl:
            case "ArrowRight" when !isVertical && isRtl:
                await FocusPreviousTrigger();
                break;

            case "Home":
                await FocusFirstTrigger();
                break;

            case "End":
                await FocusLastTrigger();
                break;
        }
    }

    private async Task FocusNextTrigger()
    {
        if (Root == null) return;

        var nextTrigger = Root.GetNextTrigger(this);
        if (nextTrigger != null)
        {
            await FocusTrigger(nextTrigger);
        }
    }

    private async Task FocusPreviousTrigger()
    {
        if (Root == null) return;

        var previousTrigger = Root.GetPreviousTrigger(this);
        if (previousTrigger != null)
        {
            await FocusTrigger(previousTrigger);
        }
    }

    private async Task FocusFirstTrigger()
    {
        if (Root == null) return;

        var firstTrigger = Root.GetFirstTrigger();
        if (firstTrigger != null)
        {
            await FocusTrigger(firstTrigger);
        }
    }

    private async Task FocusLastTrigger()
    {
        if (Root == null) return;

        var lastTrigger = Root.GetLastTrigger();
        if (lastTrigger != null)
        {
            await FocusTrigger(lastTrigger);
        }
    }

    /// <summary>
    /// Focuses a trigger element using BladixDom utility.
    /// Also notifies Root to update the tabbable (roving tabindex).
    /// </summary>
    private async Task FocusTrigger(AccordionTrigger trigger)
    {
        if (_bladixDom == null) return;

        try
        {
            await _bladixDom.Focus(trigger.ElementRef, preventScroll: false);
            // update root's tabbable trigger so tab order reflects the newly focused item
            Root?.SetTabbableTrigger(trigger);
        }
        catch (JSException)
        {
            // Silently handle JS errors (e.g., element not found, disposed, or during prerendering)
        }
        catch (InvalidOperationException)
        {
            // Handle cases where JSRuntime is not available (e.g., prerendering)
        }
    }

    public async ValueTask DisposeAsync()
    {
        // unregister from item and root
        Item?.UnregisterTrigger(this);
        Root?.UnregisterTrigger(this);
        if (_accordionKeyboard != null) await _accordionKeyboard.DisposeAsync();
        if (_bladixDom != null) await _bladixDom.DisposeAsync();
    }
}
