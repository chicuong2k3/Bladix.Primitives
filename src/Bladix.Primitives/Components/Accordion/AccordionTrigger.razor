@inject IJSRuntime JSRuntime
@inherits BladixComponentBase
@implements IAsyncDisposable

@if (AsChild)
{
    @ChildContent
}
else
{
    <button type="button"
            id="@_triggerId"
            @attributes="AdditionalAttributes"
            @onclick="HandleClick"
            @onkeydown="HandleKeyDown"
            aria-expanded="@(Item?.IsOpen == true ? "true" : "false")"
            aria-controls="@(Item?.ContentId)"
            data-state="@(Item?.IsOpen == true ? "open" : "closed")"
            data-disabled="@(_isDisabled ? "true" : null)"
            data-orientation="@Root?.Orientation.ToString().ToLowerInvariant()"
            disabled="@_isDisabled"
            class="@Class" style="@Style"
            @ref="ElementRef">
        @ChildContent
    </button>
}

@code {
    private bool _isDisabled;
    private string _triggerId = $"bladix-accordion-trigger-{Guid.NewGuid():N}";
    private BladixDom? _bladixDom;
    private AccordionKeyboard? _accordionKeyboard;

    public bool IsDisabled => _isDisabled;

    // Expose trigger id so parent item/content can reference it for aria-labelledby
    public string TriggerId => _triggerId;

    [CascadingParameter] public AccordionRoot? Root { get; set; }
    [CascadingParameter] public AccordionItem? Item { get; set; }

    protected override void OnInitialized()
    {
        _bladixDom = new BladixDom(JSRuntime);
        _accordionKeyboard = new AccordionKeyboard(JSRuntime);
        // registration moved to OnAfterRenderAsync to preserve DOM order
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // register with item and root after render to preserve DOM order for keyboard navigation
            Item?.RegisterTrigger(this);
            Root?.RegisterTrigger(this);

            if (!_isDisabled && Root != null)
            {
                try
                {
                    // Setup keyboard navigation with preventDefault via AccordionKeyboard wrapper
                    await _accordionKeyboard!.SetupKeyboardNavigation(
                        ElementRef,
                        Root.Orientation
                    );
                }
                catch (JSException) { /* Silently handle */ }
                catch (InvalidOperationException) { /* Handle JSRuntime unavailable */ }
            }
        }
    }

    protected override void OnParametersSet()
    {
        _isDisabled = (Item?.Disabled == true || Root?.Disabled == true);
    }

    private async Task HandleClick(MouseEventArgs e)
    {
        if (!_isDisabled)
        {
            await Item?.Toggle()!;
        }
    }

    /// <summary>
    /// Handles keyboard navigation for accordion triggers.
    /// Vertical: ArrowUp/ArrowDown/Home/End
    /// Horizontal: ArrowLeft/ArrowRight/Home/End (with RTL support)
    /// preventDefault is handled by AccordionKeyboard via JS module
    /// </summary>
    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (_isDisabled || Root == null) return;

        bool isVertical = Root.Orientation == Orientation.Vertical;
        bool isRtl = Root.Dir == Direction.Rtl;

        switch (e.Key)
        {
            case "ArrowDown" when isVertical:
            case "ArrowRight" when !isVertical && !isRtl:
            case "ArrowLeft" when !isVertical && isRtl:
                await FocusNextTrigger();
                break;

            case "ArrowUp" when isVertical:
            case "ArrowLeft" when !isVertical && !isRtl:
            case "ArrowRight" when !isVertical && isRtl:
                await FocusPreviousTrigger();
                break;

            case "Home":
                await FocusFirstTrigger();
                break;

            case "End":
                await FocusLastTrigger();
                break;
        }
    }

    private async Task FocusNextTrigger()
    {
        if (Root == null) return;

        var nextTrigger = Root.GetNextTrigger(this);
        if (nextTrigger != null)
        {
            await FocusTrigger(nextTrigger);
        }
    }

    private async Task FocusPreviousTrigger()
    {
        if (Root == null) return;

        var previousTrigger = Root.GetPreviousTrigger(this);
        if (previousTrigger != null)
        {
            await FocusTrigger(previousTrigger);
        }
    }

    private async Task FocusFirstTrigger()
    {
        if (Root == null) return;

        var firstTrigger = Root.GetFirstTrigger();
        if (firstTrigger != null)
        {
            await FocusTrigger(firstTrigger);
        }
    }

    private async Task FocusLastTrigger()
    {
        if (Root == null) return;

        var lastTrigger = Root.GetLastTrigger();
        if (lastTrigger != null)
        {
            await FocusTrigger(lastTrigger);
        }
    }

    /// <summary>
    /// Focuses a trigger element using BladixDom utility.
    /// </summary>
    private async Task FocusTrigger(AccordionTrigger trigger)
    {
        if (_bladixDom == null) return;

        try
        {
            await _bladixDom.Focus(trigger.ElementRef, preventScroll: false);
        }
        catch (JSException)
        {
            // Silently handle JS errors (e.g., element not found, disposed, or during prerendering)
        }
        catch (InvalidOperationException)
        {
            // Handle cases where JSRuntime is not available (e.g., prerendering)
        }
    }

    public async ValueTask DisposeAsync()
    {
        // unregister from item and root
        Item?.UnregisterTrigger(this);
        Root?.UnregisterTrigger(this);
        if (_accordionKeyboard != null) await _accordionKeyboard.DisposeAsync();
        if (_bladixDom != null) await _bladixDom.DisposeAsync();
    }
}
